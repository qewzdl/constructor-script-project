package app

import (
	"context"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"

	"constructor-script-backend/internal/authorization"
	"constructor-script-backend/internal/background"
	"constructor-script-backend/internal/config"
	"constructor-script-backend/internal/handlers"
	"constructor-script-backend/internal/middleware"
	"constructor-script-backend/internal/models"
	"constructor-script-backend/internal/plugin"
	"constructor-script-backend/internal/repository"
	"constructor-script-backend/internal/seed"
	"constructor-script-backend/internal/service"
	"constructor-script-backend/internal/theme"
	"constructor-script-backend/pkg/cache"
	"constructor-script-backend/pkg/logger"
)

type Options struct {
	ThemesDir    string
	DefaultTheme string
	PluginsDir   string
}

type Application struct {
	cfg     *config.Config
	options Options

	db        *gorm.DB
	cache     *cache.Cache
	scheduler *background.Scheduler

	repositories repositoryContainer
	services     serviceContainer
	handlers     handlerContainer

	themeManager    *theme.Manager
	pluginManager   *plugin.Manager
	templateHandler *handlers.TemplateHandler
	router          *gin.Engine
	server          *http.Server
}

type repositoryContainer struct {
	User       repository.UserRepository
	Category   repository.CategoryRepository
	Post       repository.PostRepository
	Tag        repository.TagRepository
	Comment    repository.CommentRepository
	Search     repository.SearchRepository
	Page       repository.PageRepository
	Setting    repository.SettingRepository
	SocialLink repository.SocialLinkRepository
	Menu       repository.MenuRepository
	Plugin     repository.PluginRepository
}

type serviceContainer struct {
	Auth        *service.AuthService
	Category    *service.CategoryService
	Post        *service.PostService
	Comment     *service.CommentService
	Search      *service.SearchService
	Upload      *service.UploadService
	Backup      *service.BackupService
	Page        *service.PageService
	Setup       *service.SetupService
	SocialLink  *service.SocialLinkService
	Menu        *service.MenuService
	Theme       *service.ThemeService
	Advertising *service.AdvertisingService
	Plugin      *service.PluginService
}

type handlerContainer struct {
	Auth        *handlers.AuthHandler
	Category    *handlers.CategoryHandler
	Post        *handlers.PostHandler
	Comment     *handlers.CommentHandler
	Search      *handlers.SearchHandler
	Upload      *handlers.UploadHandler
	Backup      *handlers.BackupHandler
	Page        *handlers.PageHandler
	Setup       *handlers.SetupHandler
	SocialLink  *handlers.SocialLinkHandler
	Menu        *handlers.MenuHandler
	SEO         *handlers.SEOHandler
	Theme       *handlers.ThemeHandler
	Advertising *handlers.AdvertisingHandler
	Plugin      *handlers.PluginHandler
}

func New(cfg *config.Config, opts Options) (*Application, error) {
	if cfg == nil {
		return nil, fmt.Errorf("config is required")
	}

	if opts.ThemesDir == "" {
		opts.ThemesDir = "./themes"
	}

	if opts.DefaultTheme == "" {
		opts.DefaultTheme = "default"
	}

	if opts.PluginsDir == "" {
		opts.PluginsDir = "./plugins"
	}

	if cfg.JWTSecretAutoGenerated {
		logger.Warn("JWT secret was automatically generated; set JWT_SECRET to a strong, persistent value", map[string]interface{}{
			"cause":  cfg.JWTSecretAutoGeneratedCause,
			"length": len(cfg.JWTSecret),
		})
	}

	app := &Application{
		cfg:     cfg,
		options: opts,
	}

	if err := app.initDatabase(); err != nil {
		return nil, err
	}

	if err := app.runMigrations(); err != nil {
		return nil, err
	}

	if err := app.createIndexes(); err != nil {
		return nil, err
	}

	app.initCache()
	app.initRepositories()

	app.scheduler = background.NewScheduler(background.SchedulerConfig{})
	app.scheduler.Start(context.Background())

	cleanupNeeded := true
	defer func() {
		if !cleanupNeeded {
			return
		}
		if app.scheduler != nil {
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()
			if err := app.scheduler.Shutdown(shutdownCtx); err != nil && !errors.Is(err, context.Canceled) {
				logger.Error(err, "Failed to stop background scheduler during initialization", nil)
			}
		}
	}()

	if err := app.initThemeManager(); err != nil {
		return nil, err
	}

	if err := app.initPluginManager(); err != nil {
		return nil, err
	}

	app.initServices()

	seed.EnsureDefaultCategory(app.services.Category)

	if theme := app.themeManager.Active(); theme != nil {
		applyDefaults := true
		if app.services.Theme != nil {
			if needsInitialization, err := app.services.Theme.RequiresInitialization(theme.Slug); err != nil {
				logger.Error(err, "Failed to determine if theme defaults should be applied", map[string]interface{}{"theme": theme.Slug})
				applyDefaults = false
			} else {
				applyDefaults = needsInitialization
			}
		}

		if applyDefaults {
			seed.EnsureDefaultPages(app.services.Page, theme.PagesFS())
			seed.EnsureDefaultMenu(app.services.Menu, theme.MenuFS())
			seed.EnsureDefaultPosts(app.services.Post, app.repositories.User, theme.PostsFS())

			if app.services.Theme != nil {
				if err := app.services.Theme.MarkInitialized(theme.Slug); err != nil {
					logger.Error(err, "Failed to mark theme defaults as applied", map[string]interface{}{"theme": theme.Slug})
				}
			}
		}
	}

	if err := app.initHandlers(); err != nil {
		return nil, err
	}

	if err := app.initRouter(); err != nil {
		return nil, err
	}

	app.server = &http.Server{
		Addr:           ":" + cfg.Port,
		Handler:        app.router,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	cleanupNeeded = false
	return app, nil
}

func (a *Application) Run() error {
	logger.Info("Server starting", map[string]interface{}{
		"port":        a.cfg.Port,
		"environment": a.cfg.Environment,
	})

	return a.server.ListenAndServe()
}

func (a *Application) Shutdown(ctx context.Context) error {
	if a.server != nil {
		if err := a.server.Shutdown(ctx); err != nil {
			return err
		}
	}

	if a.scheduler != nil {
		if err := a.scheduler.Shutdown(ctx); err != nil && !errors.Is(err, context.Canceled) {
			logger.Error(err, "Failed to shut down background scheduler", nil)
		}
	}

	if a.services.Backup != nil {
		a.services.Backup.ShutdownAutoBackups()
	}

	if a.cache != nil {
		if err := a.cache.Close(); err != nil {
			logger.Error(err, "Failed to close cache connection", nil)
		}
	}

	if a.db != nil {
		if sqlDB, err := a.db.DB(); err == nil {
			sqlDB.Close()
		}
	}

	return nil
}

func (a *Application) Router() *gin.Engine {
	return a.router
}

func (a *Application) initDatabase() error {
	logger.Info("Connecting to database", nil)

	db, err := gorm.Open(postgres.Open(a.cfg.DatabaseURL), &gorm.Config{
		Logger: logger.NewGormLogger(),
	})
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		return fmt.Errorf("failed to get database instance: %w", err)
	}

	sqlDB.SetMaxIdleConns(10)
	sqlDB.SetMaxOpenConns(100)
	sqlDB.SetConnMaxLifetime(time.Hour)

	a.db = db
	return nil
}

func (a *Application) runMigrations() error {
	if a.db == nil {
		return fmt.Errorf("database connection is not initialized")
	}

	logger.Info("Running database migrations", nil)

	migrator := a.db.Migrator()

	if migrator.HasTable(&models.Page{}) && !migrator.HasColumn(&models.Page{}, "path") {
		if err := a.db.Exec("ALTER TABLE pages ADD COLUMN path text").Error; err != nil {
			return fmt.Errorf("failed to add page path column: %w", err)
		}
	}

	if err := a.db.AutoMigrate(
		&models.User{},
		&models.Category{},
		&models.Post{},
		&models.PostViewStat{},
		&models.Page{},
		&models.Tag{},
		&models.Comment{},
		&models.Setting{},
		&models.SocialLink{},
		&models.MenuItem{},
		&models.Plugin{},
	); err != nil {
		return fmt.Errorf("failed to migrate database: %w", err)
	}

	if err := a.db.Exec(`
                UPDATE posts
                SET publish_at = COALESCE(publish_at, created_at)
                WHERE publish_at IS NULL AND published = TRUE
        `).Error; err != nil {
		return fmt.Errorf("failed to backfill post publish_at: %w", err)
	}

	if err := a.db.Exec(`
                UPDATE posts
                SET published_at = COALESCE(published_at, publish_at, created_at)
                WHERE published = TRUE
        `).Error; err != nil {
		return fmt.Errorf("failed to backfill post published_at: %w", err)
	}

	if err := a.db.Exec(`
                UPDATE pages
                SET publish_at = COALESCE(publish_at, created_at)
                WHERE publish_at IS NULL AND published = TRUE
        `).Error; err != nil {
		return fmt.Errorf("failed to backfill page publish_at: %w", err)
	}

	if err := a.db.Exec(`
                UPDATE pages
                SET published_at = COALESCE(published_at, publish_at, created_at)
                WHERE published = TRUE
        `).Error; err != nil {
		return fmt.Errorf("failed to backfill page published_at: %w", err)
	}

	if migrator.HasTable(&models.Page{}) {
		if err := a.db.Exec(`
                        UPDATE pages
                        SET path = CASE
                                WHEN slug = 'home' THEN '/'
                                ELSE '/' || slug
                        END
                        WHERE (path IS NULL OR path = '') AND slug <> ''
                `).Error; err != nil {
			return fmt.Errorf("failed to backfill page paths: %w", err)
		}

		if err := a.db.Exec(`
                        UPDATE pages
                        SET path = '/'
                        WHERE (path IS NULL OR path = '') AND slug = ''
                `).Error; err != nil {
			return fmt.Errorf("failed to normalize empty page paths: %w", err)
		}

		if err := a.db.Exec("ALTER TABLE pages ALTER COLUMN path SET NOT NULL").Error; err != nil {
			return fmt.Errorf("failed to enforce page path requirement: %w", err)
		}

		if err := a.db.Exec("CREATE UNIQUE INDEX IF NOT EXISTS idx_pages_path ON pages(path)").Error; err != nil {
			return fmt.Errorf("failed to ensure page path uniqueness: %w", err)
		}
	}

	logger.Info("Database migration completed", nil)
	return nil
}

func (a *Application) createIndexes() error {
	if a.db == nil {
		return fmt.Errorf("database connection is not initialized")
	}

	logger.Info("Creating database indexes", nil)

	statements := []string{
		"CREATE INDEX IF NOT EXISTS idx_posts_published ON posts(published) WHERE published = true",
		"CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at DESC)",
		"CREATE INDEX IF NOT EXISTS idx_posts_publish_at ON posts(publish_at)",
		"CREATE INDEX IF NOT EXISTS idx_posts_slug ON posts(slug) WHERE published = true",
		"CREATE INDEX IF NOT EXISTS idx_posts_template ON posts(template)",
		"CREATE INDEX IF NOT EXISTS idx_pages_published ON pages(published) WHERE published = true",
		"CREATE INDEX IF NOT EXISTS idx_pages_slug ON pages(slug) WHERE published = true",
		"CREATE INDEX IF NOT EXISTS idx_pages_path ON pages(path) WHERE published = true",
		"CREATE INDEX IF NOT EXISTS idx_pages_publish_at ON pages(publish_at)",
		"CREATE INDEX IF NOT EXISTS idx_pages_order ON pages(\"order\" ASC)",
		"CREATE INDEX IF NOT EXISTS idx_posts_sections ON posts USING GIN (sections)",
		"CREATE INDEX IF NOT EXISTS idx_pages_sections ON pages USING GIN (sections)",
		"CREATE UNIQUE INDEX IF NOT EXISTS idx_post_view_stats_post_date ON post_view_stats(post_id, date)",
	}

	for _, stmt := range statements {
		if err := a.db.Exec(stmt).Error; err != nil {
			return fmt.Errorf("failed to create index: %w", err)
		}
	}

	return nil
}

func (a *Application) initCache() {
	if a.cfg.EnableCache {
		a.cache = cache.NewCache(a.cfg.RedisURL, true)
	} else {
		a.cache = cache.NewCache("", false)
	}
}

func (a *Application) initRepositories() {
	a.repositories = repositoryContainer{
		User:       repository.NewUserRepository(a.db),
		Category:   repository.NewCategoryRepository(a.db),
		Post:       repository.NewPostRepository(a.db),
		Tag:        repository.NewTagRepository(a.db),
		Comment:    repository.NewCommentRepository(a.db),
		Search:     repository.NewSearchRepository(a.db),
		Page:       repository.NewPageRepository(a.db),
		Setting:    repository.NewSettingRepository(a.db),
		SocialLink: repository.NewSocialLinkRepository(a.db),
		Menu:       repository.NewMenuRepository(a.db),
		Plugin:     repository.NewPluginRepository(a.db),
	}
}

func (a *Application) initThemeManager() error {
	manager, err := theme.NewManager(a.options.ThemesDir)
	if err != nil {
		return fmt.Errorf("failed to load themes: %w", err)
	}

	activeSlug := strings.ToLower(strings.TrimSpace(a.options.DefaultTheme))
	storedSlug := ""

	if a.repositories.Setting != nil {
		setting, err := a.repositories.Setting.Get(service.SettingKeyActiveTheme)
		if err == nil && setting != nil {
			storedSlug = strings.ToLower(strings.TrimSpace(setting.Value))
			if storedSlug != "" {
				activeSlug = storedSlug
			}
		} else if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			logger.Error(err, "Failed to read active theme setting", nil)
		}
	}

	finalSlug := activeSlug

	if err := manager.Activate(activeSlug); err != nil {
		logger.Error(err, "Failed to activate stored theme, attempting default", map[string]interface{}{"theme": activeSlug})
		if fallbackErr := manager.Activate(a.options.DefaultTheme); fallbackErr != nil {
			return fmt.Errorf("failed to activate default theme: %w", fallbackErr)
		}
		finalSlug = a.options.DefaultTheme
	}

	if a.repositories.Setting != nil {
		if storedSlug == "" || storedSlug != finalSlug {
			if err := a.repositories.Setting.Set(service.SettingKeyActiveTheme, finalSlug); err != nil {
				logger.Error(err, "Failed to persist active theme setting", map[string]interface{}{"theme": finalSlug})
			}
		}
	}

	a.themeManager = manager
	return nil
}

func (a *Application) initPluginManager() error {
	manager, err := plugin.NewManager(a.options.PluginsDir)
	if err != nil {
		return fmt.Errorf("failed to load plugins: %w", err)
	}

	a.pluginManager = manager
	return nil
}

func (a *Application) initServices() {
	uploadService := service.NewUploadService(a.cfg.UploadDir)

	backupOptions := service.BackupOptions{UploadDir: a.cfg.UploadDir}

	if key := strings.TrimSpace(a.cfg.BackupEncryptionKey); key != "" {
		decoded, err := base64.StdEncoding.DecodeString(key)
		if err != nil {
			logger.Error(err, "Invalid backup encryption key", nil)
		} else if len(decoded) < 32 {
			logger.Warn("Backup encryption key must be at least 32 bytes after base64 decoding; encryption disabled", map[string]interface{}{"provided_length": len(decoded)})
		} else {
			backupOptions.EncryptionKey = decoded
		}
	}

	if a.cfg.BackupS3Enabled {
		endpoint := strings.TrimSpace(a.cfg.BackupS3Endpoint)
		accessKey := strings.TrimSpace(a.cfg.BackupS3AccessKey)
		secretKey := strings.TrimSpace(a.cfg.BackupS3SecretKey)
		bucket := strings.TrimSpace(a.cfg.BackupS3Bucket)

		if endpoint == "" || accessKey == "" || secretKey == "" || bucket == "" {
			logger.Warn("Incomplete S3 backup configuration; remote uploads disabled", map[string]interface{}{
				"endpoint_configured": endpoint != "",
				"bucket_configured":   bucket != "",
				"access_configured":   accessKey != "" && secretKey != "",
			})
		} else {
			backupOptions.S3 = &service.BackupS3Config{
				Endpoint:  endpoint,
				AccessKey: accessKey,
				SecretKey: secretKey,
				Bucket:    bucket,
				Region:    strings.TrimSpace(a.cfg.BackupS3Region),
				UseSSL:    a.cfg.BackupS3UseSSL,
				Prefix:    strings.Trim(a.cfg.BackupS3Prefix, "/"),
			}
		}
	}

	backupService := service.NewBackupService(a.db, a.repositories.Setting, backupOptions)

	authService := service.NewAuthService(a.repositories.User, a.cfg.JWTSecret)
	categoryService := service.NewCategoryService(a.repositories.Category, a.repositories.Post, a.cache)
	postService := service.NewPostService(
		a.repositories.Post,
		a.repositories.Tag,
		a.repositories.Category,
		a.repositories.Comment,
		a.cache,
		a.repositories.Setting,
		a.scheduler,
		a.themeManager,
	)
	commentService := service.NewCommentService(a.repositories.Comment)
	searchService := service.NewSearchService(a.repositories.Search)
	pageService := service.NewPageService(a.repositories.Page, a.cache, a.themeManager)
	setupService := service.NewSetupService(a.repositories.User, a.repositories.Setting, uploadService)
	socialLinkService := service.NewSocialLinkService(a.repositories.SocialLink)
	menuService := service.NewMenuService(a.repositories.Menu)
	advertisingService := service.NewAdvertisingService(a.repositories.Setting)

	themeService := service.NewThemeService(
		a.repositories.Setting,
		a.themeManager,
		a.options.DefaultTheme,
	)

	pluginService := service.NewPluginService(
		a.repositories.Plugin,
		a.pluginManager,
	)

	a.services = serviceContainer{
		Auth:        authService,
		Category:    categoryService,
		Post:        postService,
		Comment:     commentService,
		Search:      searchService,
		Upload:      uploadService,
		Backup:      backupService,
		Page:        pageService,
		Setup:       setupService,
		SocialLink:  socialLinkService,
		Menu:        menuService,
		Theme:       themeService,
		Advertising: advertisingService,
		Plugin:      pluginService,
	}

	backupService.InitializeAutoBackups()
}

func (a *Application) initHandlers() error {
	commentGuard := handlers.NewCommentGuard(a.cfg)

	a.handlers = handlerContainer{
		Auth:        handlers.NewAuthHandler(a.services.Auth),
		Category:    handlers.NewCategoryHandler(a.services.Category),
		Post:        handlers.NewPostHandler(a.services.Post),
		Comment:     handlers.NewCommentHandler(a.services.Comment, a.services.Auth, commentGuard),
		Search:      handlers.NewSearchHandler(a.services.Search),
		Upload:      handlers.NewUploadHandler(a.services.Upload),
		Backup:      handlers.NewBackupHandler(a.services.Backup),
		Page:        handlers.NewPageHandler(a.services.Page),
		Setup:       handlers.NewSetupHandler(a.services.Setup, a.cfg),
		SocialLink:  handlers.NewSocialLinkHandler(a.services.SocialLink),
		Menu:        handlers.NewMenuHandler(a.services.Menu),
		SEO:         handlers.NewSEOHandler(a.services.Post, a.services.Page, a.services.Category, a.services.Setup, a.cfg),
		Advertising: handlers.NewAdvertisingHandler(a.services.Advertising),
		Plugin:      handlers.NewPluginHandler(a.services.Plugin),
	}

	templateHandler, err := handlers.NewTemplateHandler(
		a.services.Post,
		a.services.Page,
		a.services.Auth,
		a.services.Comment,
		a.services.Search,
		a.services.Setup,
		a.services.Category,
		a.services.SocialLink,
		a.services.Menu,
		a.services.Advertising,
		a.cfg,
		a.themeManager,
	)
	if err != nil {
		return fmt.Errorf("failed to initialize template handler: %w", err)
	}

	a.templateHandler = templateHandler

	a.handlers.Theme = handlers.NewThemeHandler(
		a.services.Theme,
		a.services.Page,
		a.services.Menu,
		a.services.Post,
		a.repositories.User,
		a.templateHandler,
	)
	return nil
}

func (a *Application) initRouter() error {
	if a.cfg.Environment == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	router := gin.New()
	if err := router.SetTrustedProxies(nil); err != nil {
		return fmt.Errorf("failed to configure trusted proxies: %w", err)
	}

	router.Use(logger.GinRecovery(true))
	router.Use(middleware.RequestIDMiddleware())
	router.Use(logger.GinLogger())
	router.Use(middleware.SecurityHeadersMiddleware(a.services.Advertising))
	router.Use(middleware.MetricsMiddleware())
	router.Use(middleware.RateLimitMiddleware(a.cfg))
	router.Use(middleware.CSRFMiddleware())

	router.Use(cors.New(cors.Config{
		AllowOrigins:     a.cfg.CORSOrigins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	router.Use(middleware.SetupMiddleware(a.services.Setup))

	if a.themeManager != nil {
		if active := a.themeManager.Active(); active != nil {
			logger.Info("Active theme loaded", map[string]interface{}{"theme": active.Slug})
		}
	}

	router.GET("/health", middleware.NoIndexMiddleware(), func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status": "healthy",
			"time":   time.Now().Format(time.RFC3339),
		})
	})

	router.GET("/metrics", middleware.NoIndexMiddleware(), a.metricsHandler())

	if a.themeManager != nil {
		router.StaticFS("/static", theme.NewFileSystem(a.themeManager))
	} else {
		router.Static("/static", "./static")
	}
	router.Static("/uploads", a.cfg.UploadDir)
	router.StaticFile("/favicon.ico", "./favicon.ico")

	if a.handlers.SEO != nil {
		router.GET("/sitemap.xml", a.handlers.SEO.Sitemap)
		router.GET("/robots.txt", a.handlers.SEO.Robots)
	}

	router.GET("/debug-templates", middleware.NoIndexMiddleware(), func(c *gin.Context) {
		if a.themeManager == nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"error": "theme manager unavailable"})
			return
		}

		active := a.themeManager.Active()
		if active == nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"error": "no active theme"})
			return
		}

		names, err := active.TemplateNames()
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":   "failed to enumerate templates",
				"details": err.Error(),
			})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"theme":     active.Slug,
			"templates": names,
		})
	})

	router.GET("/", a.templateHandler.RenderIndex)
	router.GET("/login", a.templateHandler.RenderLogin)
	router.GET("/register", a.templateHandler.RenderRegister)
	router.GET("/setup", a.templateHandler.RenderSetup)
	router.GET("/profile", a.templateHandler.RenderProfile)
	router.GET("/admin", a.templateHandler.RenderAdmin)
	router.GET("/blog/post/:slug", a.templateHandler.RenderPost)
	router.GET("/page/:slug", a.templateHandler.RenderPage)
	router.GET("/blog", a.templateHandler.RenderBlog)
	router.GET("/search", a.templateHandler.RenderSearch)
	router.GET("/category/:slug", a.templateHandler.RenderCategory)
	router.GET("/tag/:slug", a.templateHandler.RenderTag)

	v1 := router.Group("/api/v1")
	v1.Use(middleware.NoIndexMiddleware())
	{
		public := v1.Group("")
		{
			public.GET("/setup/status", a.handlers.Setup.Status)
			public.POST("/setup", a.handlers.Setup.Complete)
			public.POST("/register", a.handlers.Auth.Register)
			public.POST("/login", a.handlers.Auth.Login)
			public.POST("/logout", a.handlers.Auth.Logout)
			public.POST("/refresh", a.handlers.Auth.RefreshToken)

			public.GET("/posts", a.handlers.Post.GetAll)
			public.GET("/posts/:id", a.handlers.Post.GetByID)
			public.GET("/posts/slug/:slug", a.handlers.Post.GetBySlug)

			public.GET("/pages", a.handlers.Page.GetAll)
			public.GET("/pages/:id", a.handlers.Page.GetByID)
			public.GET("/pages/slug/:slug", a.handlers.Page.GetBySlug)

			public.GET("/categories", a.handlers.Category.GetAll)
			public.GET("/categories/:id", a.handlers.Category.GetByID)

			public.GET("/posts/:id/comments", a.handlers.Comment.GetByPostID)

			public.GET("/search", a.handlers.Search.Search)

			public.GET("/tags", a.handlers.Post.GetAllTags)
			public.GET("/tags/:slug/posts", a.handlers.Post.GetPostsByTag)
		}

		protected := v1.Group("")
		protected.Use(middleware.AuthMiddleware(a.cfg.JWTSecret))
		{
			protected.POST("/posts/:id/comments", a.handlers.Comment.Create)
			protected.PUT("/comments/:id", a.handlers.Comment.Update)
			protected.DELETE("/comments/:id", a.handlers.Comment.Delete)

			protected.GET("/profile", a.handlers.Auth.GetProfile)
			protected.PUT("/profile", a.handlers.Auth.UpdateProfile)
			protected.PUT("/profile/password", a.handlers.Auth.ChangePassword)
		}

		admin := v1.Group("/admin")
		admin.Use(middleware.AuthMiddleware(a.cfg.JWTSecret))

		content := admin.Group("")
		content.Use(middleware.RequirePermissions(authorization.PermissionManageAllContent))
		{
			content.POST("/posts", a.handlers.Post.Create)
			content.PUT("/posts/:id", a.handlers.Post.Update)
			content.DELETE("/posts/:id", a.handlers.Post.Delete)
			content.GET("/posts", a.handlers.Post.GetAllAdmin)
			content.GET("/posts/:id/analytics", a.handlers.Post.GetAnalytics)

			content.POST("/pages", a.handlers.Page.Create)
			content.PUT("/pages/:id", a.handlers.Page.Update)
			content.DELETE("/pages/:id", a.handlers.Page.Delete)
			content.GET("/pages", a.handlers.Page.GetAllAdmin)

			content.POST("/upload", a.handlers.Upload.UploadImage)
			content.GET("/uploads", a.handlers.Upload.List)
			content.PUT("/uploads/rename", a.handlers.Upload.Rename)

			content.POST("/categories", a.handlers.Category.Create)
			content.PUT("/categories/:id", a.handlers.Category.Update)
			content.DELETE("/categories/:id", a.handlers.Category.Delete)

			content.DELETE("/tags/:id", a.handlers.Post.DeleteTag)
		}

		publish := admin.Group("")
		publish.Use(middleware.RequirePermissions(authorization.PermissionPublishContent))
		{
			publish.PUT("/posts/:id/publish", a.handlers.Post.PublishPost)
			publish.PUT("/posts/:id/unpublish", a.handlers.Post.UnpublishPost)
			publish.PUT("/pages/:id/publish", a.handlers.Page.PublishPage)
			publish.PUT("/pages/:id/unpublish", a.handlers.Page.UnpublishPage)
		}

		users := admin.Group("")
		users.Use(middleware.RequirePermissions(authorization.PermissionManageUsers))
		{
			users.GET("/users", a.handlers.Auth.GetAllUsers)
			users.GET("/users/:id", a.handlers.Auth.GetUser)
			users.DELETE("/users/:id", a.handlers.Auth.DeleteUser)
			users.PUT("/users/:id/role", a.handlers.Auth.UpdateUserRole)
			users.PUT("/users/:id/status", a.handlers.Auth.UpdateUserStatus)
		}

		comments := admin.Group("")
		comments.Use(middleware.RequirePermissions(authorization.PermissionModerateComments))
		{
			comments.GET("/comments", a.handlers.Comment.GetAll)
			comments.DELETE("/comments/:id", a.handlers.Comment.Delete)
			comments.PUT("/comments/:id/approve", a.handlers.Comment.ApproveComment)
			comments.PUT("/comments/:id/reject", a.handlers.Comment.RejectComment)
		}

		settings := admin.Group("")
		settings.Use(middleware.RequirePermissions(authorization.PermissionManageSettings))
		{
			settings.GET("/settings/site", a.handlers.Setup.GetSiteSettings)
			settings.PUT("/settings/site", a.handlers.Setup.UpdateSiteSettings)
			settings.POST("/settings/favicon", a.handlers.Setup.UploadFavicon)
			settings.POST("/settings/logo", a.handlers.Setup.UploadLogo)
			settings.GET("/settings/advertising", a.handlers.Advertising.Get)
			settings.PUT("/settings/advertising", a.handlers.Advertising.Update)

			settings.GET("/social-links", a.handlers.SocialLink.List)
			settings.POST("/social-links", a.handlers.SocialLink.Create)
			settings.PUT("/social-links/:id", a.handlers.SocialLink.Update)
			settings.DELETE("/social-links/:id", a.handlers.SocialLink.Delete)

			settings.GET("/menu-items", a.handlers.Menu.List)
			settings.POST("/menu-items", a.handlers.Menu.Create)
			settings.PUT("/menu-items/reorder", a.handlers.Menu.Reorder)
			settings.PUT("/menu-items/:id", a.handlers.Menu.Update)
			settings.DELETE("/menu-items/:id", a.handlers.Menu.Delete)

			settings.GET("/stats", handlers.GetStatistics(a.db))

			if a.cache != nil {
				settings.DELETE("/cache", handlers.ClearCache(a.cache))
			}
		}

		themes := admin.Group("")
		themes.Use(middleware.RequirePermissions(authorization.PermissionManageThemes))
		{
			themes.GET("/themes", a.handlers.Theme.List)
			themes.PUT("/themes/:slug/activate", a.handlers.Theme.Activate)
			themes.PUT("/themes/:slug/reload", a.handlers.Theme.Reload)
		}

		plugins := admin.Group("")
		plugins.Use(middleware.RequirePermissions(authorization.PermissionManagePlugins))
		{
			plugins.GET("/plugins", a.handlers.Plugin.List)
			plugins.POST("/plugins", a.handlers.Plugin.Install)
			plugins.PUT("/plugins/:slug/activate", a.handlers.Plugin.Activate)
			plugins.PUT("/plugins/:slug/deactivate", a.handlers.Plugin.Deactivate)
		}

		backups := admin.Group("")
		backups.Use(middleware.RequirePermissions(authorization.PermissionManageBackups))
		{
			backups.GET("/backups/settings", a.handlers.Backup.GetSettings)
			backups.PUT("/backups/settings", a.handlers.Backup.UpdateSettings)
			backups.GET("/backups/export", a.handlers.Backup.Export)
			backups.POST("/backups/import", a.handlers.Backup.Import)
		}
	}

	router.NoRoute(func(c *gin.Context) {
		if strings.HasPrefix(c.Request.URL.Path, "/api") {
			c.Header("X-Robots-Tag", "noindex, nofollow")
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Route not found",
				"path":  c.Request.URL.Path,
			})
			return
		}

		if a.templateHandler != nil {
			if a.templateHandler.TryRenderPage(c) {
				return
			}
			a.templateHandler.RenderErrorPage(c, http.StatusNotFound, "404 - Page not found", "The requested page could not be found")
			return
		}

		c.JSON(http.StatusNotFound, gin.H{
			"error": "Route not found",
			"path":  c.Request.URL.Path,
		})
	})

	a.router = router
	return nil
}

func (a *Application) metricsHandler() gin.HandlerFunc {
	promHandler := promhttp.Handler()

	allowedExact := make(map[string]struct{})
	var allowedNetworks []*net.IPNet

	for _, value := range a.cfg.MetricsAllowedIPs {
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}

		if strings.Contains(trimmed, "/") {
			if _, network, err := net.ParseCIDR(trimmed); err == nil {
				allowedNetworks = append(allowedNetworks, network)
			} else {
				logger.Warn("Invalid metrics allowed IP entry", map[string]interface{}{
					"value": trimmed,
					"error": err.Error(),
				})
			}
			continue
		}

		ip := net.ParseIP(trimmed)
		if ip == nil {
			logger.Warn("Invalid metrics allowed IP entry", map[string]interface{}{
				"value": trimmed,
			})
			continue
		}

		allowedExact[ip.String()] = struct{}{}
	}

	authUser := strings.TrimSpace(a.cfg.MetricsBasicAuthUsername)
	authPassword := a.cfg.MetricsBasicAuthPassword
	authConfigured := authUser != "" && authPassword != ""
	ipConfigured := len(allowedExact) > 0 || len(allowedNetworks) > 0

	return func(c *gin.Context) {
		if !a.cfg.EnableMetrics {
			c.AbortWithStatus(http.StatusNotFound)
			return
		}

		clientIPStr := c.ClientIP()
		clientIP := net.ParseIP(clientIPStr)

		if ipConfigured {
			if clientIP != nil {
				if _, ok := allowedExact[clientIP.String()]; ok {
					promHandler.ServeHTTP(c.Writer, c.Request)
					c.Abort()
					return
				}

				for _, network := range allowedNetworks {
					if network.Contains(clientIP) {
						promHandler.ServeHTTP(c.Writer, c.Request)
						c.Abort()
						return
					}
				}
			}

			if !authConfigured {
				c.AbortWithStatus(http.StatusForbidden)
				return
			}
		}

		if authConfigured {
			username, password, ok := c.Request.BasicAuth()
			if ok && subtle.ConstantTimeCompare([]byte(username), []byte(authUser)) == 1 &&
				subtle.ConstantTimeCompare([]byte(password), []byte(authPassword)) == 1 {
				promHandler.ServeHTTP(c.Writer, c.Request)
				c.Abort()
				return
			}

			c.Header("WWW-Authenticate", `Basic realm="metrics"`)
			c.AbortWithStatus(http.StatusUnauthorized)
			return
		}

		if clientIP != nil && clientIP.IsLoopback() {
			promHandler.ServeHTTP(c.Writer, c.Request)
			c.Abort()
			return
		}

		c.AbortWithStatus(http.StatusForbidden)
	}
}
