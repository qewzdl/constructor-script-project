package service

import (
	"context"
	"errors"
	"math"
	"mime/multipart"
	"net/url"
	"os"
	"path"
	"strings"
	"unicode/utf8"

	"constructor-script-backend/internal/models"
	"constructor-script-backend/internal/repository"
	"constructor-script-backend/internal/service"
	"constructor-script-backend/internal/theme"
)

type VideoService struct {
	videoRepo     repository.CourseVideoRepository
	uploadService *service.UploadService
	themes        *theme.Manager
}

const (
	defaultCourseVideoAttachmentTitle   = "Download"
	maxCourseVideoAttachmentTitleLength = 200
	autoGeneratedSubtitleTitle          = "Auto-generated subtitles"
)

func NewVideoService(videoRepo repository.CourseVideoRepository, uploadService *service.UploadService, themes *theme.Manager) *VideoService {
	return &VideoService{
		videoRepo:     videoRepo,
		uploadService: uploadService,
		themes:        themes,
	}
}

func (s *VideoService) SetUploadService(uploadService *service.UploadService) {
	if s == nil {
		return
	}
	s.uploadService = uploadService
}

func (s *VideoService) SetThemeManager(manager *theme.Manager) {
	if s == nil {
		return
	}
	s.themes = manager
}

func (s *VideoService) Create(ctx context.Context, req models.CreateCourseVideoRequest, file *multipart.FileHeader) (*models.CourseVideo, error) {
	if s == nil || s.videoRepo == nil {
		return nil, errors.New("course video repository is not configured")
	}
	if s.uploadService == nil {
		return nil, errors.New("upload service is not configured")
	}
	if file == nil {
		return nil, newValidationError("video file is required")
	}

	title := strings.TrimSpace(req.Title)
	if title == "" {
		return nil, newValidationError("video title is required")
	}

	result, err := s.uploadService.UploadVideo(ctx, file, req.Preferred)
	if err != nil {
		return nil, err
	}

	url := result.Video.URL
	filename := result.Video.Filename
	duration := result.Duration

	seconds := int(math.Round(duration.Seconds()))
	if seconds <= 0 && duration > 0 {
		seconds = 1
	}

	sections, err := service.PrepareSections(req.Sections, s.themes, service.PrepareSectionsOptions{NormaliseSpacing: true})
	if err != nil {
		return nil, err
	}

	attachmentInput := make([]models.CourseVideoAttachment, 0, len(req.Attachments)+1)
	if result.Subtitle != nil {
		attachmentInput = append(attachmentInput, models.CourseVideoAttachment{
			Title: autoGeneratedSubtitleTitle,
			URL:   result.Subtitle.URL,
		})
	}
	if len(req.Attachments) > 0 {
		attachmentInput = append(attachmentInput, req.Attachments...)
	}

	attachments := sanitizeCourseVideoAttachments(attachmentInput)

	video := models.CourseVideo{
		Title:           title,
		Description:     strings.TrimSpace(req.Description),
		FileURL:         url,
		Filename:        filename,
		DurationSeconds: seconds,
		Sections:        sections,
		Attachments:     attachments,
	}

	if err := s.videoRepo.Create(&video); err != nil {
		s.uploadService.DeleteImage(url)
		return nil, err
	}

	return &video, nil
}

func (s *VideoService) Update(id uint, req models.UpdateCourseVideoRequest) (*models.CourseVideo, error) {
	if s == nil || s.videoRepo == nil {
		return nil, errors.New("course video repository is not configured")
	}

	video, err := s.videoRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	title := strings.TrimSpace(req.Title)
	if title == "" {
		return nil, newValidationError("video title is required")
	}

	video.Title = title
	video.Description = strings.TrimSpace(req.Description)

	if req.Sections != nil {
		sections, err := service.PrepareSections(*req.Sections, s.themes, service.PrepareSectionsOptions{NormaliseSpacing: true})
		if err != nil {
			return nil, err
		}
		video.Sections = sections
	}

	if req.Attachments != nil {
		video.Attachments = sanitizeCourseVideoAttachments(*req.Attachments)
	}

	if err := s.videoRepo.Update(video); err != nil {
		return nil, err
	}

	return video, nil
}

func (s *VideoService) UpdateSubtitle(ctx context.Context, id uint, req models.UpdateCourseVideoSubtitleRequest) (*models.CourseVideo, error) {
	if s == nil || s.videoRepo == nil {
		return nil, errors.New("course video repository is not configured")
	}
	if s.uploadService == nil {
		return nil, errors.New("upload service is not configured")
	}

	_ = ctx

	if strings.TrimSpace(req.Content) == "" {
		return nil, newValidationError("subtitle content is required")
	}

	video, err := s.videoRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	attachments := video.Attachments
	index, existing, hasExisting := findCourseVideoSubtitleAttachment(attachments, req.AttachmentURL)

	desiredTitle := strings.TrimSpace(req.Title)
	if desiredTitle == "" {
		if hasExisting && strings.TrimSpace(existing.Title) != "" {
			desiredTitle = existing.Title
		} else {
			desiredTitle = autoGeneratedSubtitleTitle
		}
	}

	info, err := s.uploadService.SaveSubtitle(video.Filename, []byte(req.Content), desiredTitle)
	if err != nil {
		if errors.Is(err, service.ErrSubtitleContentEmpty) {
			return nil, newValidationError("subtitle content is required")
		}
		return nil, err
	}

	updated := make([]models.CourseVideoAttachment, 0, len(attachments)+1)
	updated = append(updated, models.CourseVideoAttachment{Title: desiredTitle, URL: info.URL})
	for i, attachment := range attachments {
		if hasExisting && i == index {
			continue
		}
		updated = append(updated, attachment)
	}

	sanitized := sanitizeCourseVideoAttachments(updated)
	video.Attachments = sanitized

	if err := s.videoRepo.Update(video); err != nil {
		s.uploadService.DeleteUpload(info.URL)
		return nil, err
	}

	if hasExisting {
		existingURL := normalizeAttachmentURL(existing.URL)
		newURL := normalizeAttachmentURL(info.URL)
		if existingURL != "" && existingURL != newURL {
			_ = s.uploadService.DeleteUpload(existing.URL)
		}
	}

	return video, nil
}

func (s *VideoService) Delete(id uint) error {
	if s == nil || s.videoRepo == nil {
		return errors.New("course video repository is not configured")
	}

	video, err := s.videoRepo.GetByID(id)
	if err != nil {
		return err
	}

	if err := s.videoRepo.Delete(id); err != nil {
		return err
	}

	if s.uploadService != nil {
		if err := s.uploadService.DeleteImage(video.FileURL); err != nil && !errors.Is(err, os.ErrNotExist) {
			return err
		}
	}

	return nil
}

func (s *VideoService) GetByID(id uint) (*models.CourseVideo, error) {
	if s == nil || s.videoRepo == nil {
		return nil, errors.New("course video repository is not configured")
	}
	return s.videoRepo.GetByID(id)
}

func (s *VideoService) List() ([]models.CourseVideo, error) {
	if s == nil || s.videoRepo == nil {
		return nil, errors.New("course video repository is not configured")
	}
	return s.videoRepo.List()
}

func (s *VideoService) Exists(id uint) (bool, error) {
	if s == nil || s.videoRepo == nil {
		return false, errors.New("course video repository is not configured")
	}
	return s.videoRepo.Exists(id)
}

func sanitizeCourseVideoAttachments(input []models.CourseVideoAttachment) models.CourseVideoAttachments {
	if len(input) == 0 {
		return models.CourseVideoAttachments{}
	}

	attachments := make(models.CourseVideoAttachments, 0, len(input))
	seen := make(map[string]struct{}, len(input))

	for _, attachment := range input {
		normalizedURL := normalizeAttachmentURL(attachment.URL)
		if normalizedURL == "" {
			continue
		}
		if _, exists := seen[normalizedURL]; exists {
			continue
		}

		title := strings.TrimSpace(attachment.Title)
		if title == "" {
			title = deriveAttachmentTitle(normalizedURL)
		}
		if title == "" {
			title = defaultCourseVideoAttachmentTitle
		}
		title = clampAttachmentTitle(title)

		attachments = append(attachments, models.CourseVideoAttachment{
			Title: title,
			URL:   normalizedURL,
		})
		seen[normalizedURL] = struct{}{}
	}

	return attachments
}

func findCourseVideoSubtitleAttachment(attachments models.CourseVideoAttachments, targetURL string) (int, models.CourseVideoAttachment, bool) {
	normalizedTarget := normalizeAttachmentURL(targetURL)
	if normalizedTarget != "" {
		for index, attachment := range attachments {
			if normalizeAttachmentURL(attachment.URL) == normalizedTarget {
				return index, attachment, true
			}
		}
	}

	for index, attachment := range attachments {
		if attachmentLooksLikeSubtitle(attachment) {
			return index, attachment, true
		}
	}

	return -1, models.CourseVideoAttachment{}, false
}

func attachmentLooksLikeSubtitle(attachment models.CourseVideoAttachment) bool {
	normalizedURL := normalizeAttachmentURL(attachment.URL)
	if normalizedURL != "" {
		trimmed := normalizedURL
		if idx := strings.IndexAny(trimmed, "?#"); idx != -1 {
			trimmed = trimmed[:idx]
		}
		if strings.HasSuffix(strings.ToLower(trimmed), ".vtt") {
			return true
		}
	}
	title := strings.ToLower(strings.TrimSpace(attachment.Title))
	if title == "" {
		return false
	}
	if title == strings.ToLower(strings.TrimSpace(autoGeneratedSubtitleTitle)) {
		return true
	}
	return strings.Contains(title, "subtitle")
}

func clampAttachmentTitle(title string) string {
	if utf8.RuneCountInString(title) <= maxCourseVideoAttachmentTitleLength {
		return title
	}
	runes := []rune(title)
	return string(runes[:maxCourseVideoAttachmentTitleLength])
}

func deriveAttachmentTitle(source string) string {
	if strings.TrimSpace(source) == "" {
		return ""
	}
	parsed, err := url.Parse(source)
	var candidate string
	if err == nil {
		candidate = parsed.Path
	} else {
		candidate = source
	}
	base := path.Base(candidate)
	if base == "." || base == "/" {
		base = ""
	}
	if base == "" {
		return ""
	}
	decoded, err := url.PathUnescape(base)
	if err == nil {
		base = decoded
	}
	return strings.TrimSpace(base)
}

func normalizeAttachmentURL(raw string) string {
	trimmed := strings.TrimSpace(raw)
	if trimmed == "" {
		return ""
	}

	parsed, err := url.Parse(trimmed)
	if err != nil {
		parsed, err = url.Parse("/" + strings.TrimLeft(trimmed, "/"))
		if err != nil {
			return ""
		}
	}

	if parsed.Scheme == "" && parsed.Host == "" {
		pathValue := parsed.Path
		if !strings.HasPrefix(pathValue, "/") {
			pathValue = "/" + strings.TrimLeft(pathValue, "/")
		}
		if strings.Contains(pathValue, "..") {
			return ""
		}
		parsed.Path = pathValue
		return parsed.String()
	}

	scheme := strings.ToLower(parsed.Scheme)
	if scheme != "" && scheme != "http" && scheme != "https" {
		return ""
	}

	return parsed.String()
}
